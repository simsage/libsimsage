// tslint:disable
/**
 * SimSage REST API
 * SimSage REST API
 *
 * The version of the OpenAPI document: 7.13.31
 * Contact: info@simsage.co.uk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Observable } from 'rxjs';
import type { AjaxResponse } from 'rxjs/ajax';
import { BaseAPI, throwIfNullOrUndefined, encodeURI } from '../runtime';
import type { OperationOpts, HttpHeaders } from '../runtime';
import type {
    CMCategorization,
    CMCategorizationPaginatedList,
    CMOptimizeIndex,
    CMSemanticModelEdit,
    CMSemanticsPaginated,
    CMSemanticsPaginatedResult,
    CMSynSet,
    CMSynSetFind,
    CMSynSetList,
    CMSynonym,
    CMSynonymsPaginated,
    CMSynonymsPaginatedResult,
    CMVersion,
    JsonMessage,
} from '../models';

export interface AddDefaultSynSetsRequest {
    organisationId: string;
    kbId: string;
    sessionId: string;
    aPIVersion?: AddDefaultSynSetsAPIVersionEnum;
}

export interface DeleteAllSynonymsRequest {
    organisationId: string;
    kbId: string;
    sessionId: string;
    aPIVersion?: DeleteAllSynonymsAPIVersionEnum;
}

export interface DeleteCategorizationRequest {
    organisationId: string;
    kbId: string;
    categorizationLabel: string;
    sessionId: string;
    aPIVersion?: DeleteCategorizationAPIVersionEnum;
}

export interface DeleteSemanticRequest {
    organisationId: string;
    kbId: string;
    word: string;
    semantic: string;
    sessionId: string;
    aPIVersion?: DeleteSemanticAPIVersionEnum;
}

export interface DeleteSynSetRequest {
    organisationId: string;
    kbId: string;
    lemma: string;
    sessionId: string;
    aPIVersion?: DeleteSynSetAPIVersionEnum;
}

export interface DeleteSynonymRequest {
    organisationId: string;
    kbId: string;
    id: number;
    sessionId: string;
    aPIVersion?: DeleteSynonymAPIVersionEnum;
}

export interface FindSynSetsRequest {
    sessionId: string;
    cMSynSetFind: CMSynSetFind;
    aPIVersion?: FindSynSetsAPIVersionEnum;
}

export interface GetCategorizationListRequest {
    organisationId: string;
    kbId: string;
    prevCategorizationLabel: string;
    pageSize: number;
    sessionId: string;
    aPIVersion?: GetCategorizationListAPIVersionEnum;
}

export interface GetPaginatedRequest {
    sessionId: string;
    cMSynonymsPaginated: CMSynonymsPaginated;
    aPIVersion?: GetPaginatedAPIVersionEnum;
}

export interface GetSemanticsPaginatedRequest {
    sessionId: string;
    cMSemanticsPaginated: CMSemanticsPaginated;
    aPIVersion?: GetSemanticsPaginatedAPIVersionEnum;
}

export interface OptimizeIndexesRequest {
    sessionId: string;
    cMOptimizeIndex: CMOptimizeIndex;
    aPIVersion?: OptimizeIndexesAPIVersionEnum;
}

export interface RedactDocumentRequest {
    organisationId: string;
    kbId: string;
    url: string;
    entityCsv: string;
    wordCsv: string;
    allowWordsCsv: string;
    sessionId?: string;
}

export interface SaveCategorizationRequest {
    sessionId: string;
    cMCategorization: CMCategorization;
    aPIVersion?: SaveCategorizationAPIVersionEnum;
}

export interface SaveSemanticRequest {
    organisationId: string;
    kbId: string;
    sessionId: string;
    cMSemanticModelEdit: CMSemanticModelEdit;
    aPIVersion?: SaveSemanticAPIVersionEnum;
}

export interface SaveSynSetRequest {
    organisationId: string;
    kbId: string;
    sessionId: string;
    cMSynSet: CMSynSet;
    aPIVersion?: SaveSynSetAPIVersionEnum;
}

export interface SaveSynonymRequest {
    organisationId: string;
    kbId: string;
    sessionId: string;
    cMSynonym: CMSynonym;
    aPIVersion?: SaveSynonymAPIVersionEnum;
}

export interface TuneLanguageGraphRequest {
    organisationId: string;
    kbId: string;
    sessionId: string;
    aPIVersion?: TuneLanguageGraphAPIVersionEnum;
}

/**
 * no description
 */
export class LanguageApi extends BaseAPI {

    /**
     * Add default syn-sets to the given org/kb
     * Add all default SynSets
     */
    addDefaultSynSets({ organisationId, kbId, sessionId, aPIVersion }: AddDefaultSynSetsRequest): Observable<JsonMessage>
    addDefaultSynSets({ organisationId, kbId, sessionId, aPIVersion }: AddDefaultSynSetsRequest, opts?: OperationOpts): Observable<AjaxResponse<JsonMessage>>
    addDefaultSynSets({ organisationId, kbId, sessionId, aPIVersion }: AddDefaultSynSetsRequest, opts?: OperationOpts): Observable<JsonMessage | AjaxResponse<JsonMessage>> {
        throwIfNullOrUndefined(organisationId, 'organisationId', 'addDefaultSynSets');
        throwIfNullOrUndefined(kbId, 'kbId', 'addDefaultSynSets');
        throwIfNullOrUndefined(sessionId, 'sessionId', 'addDefaultSynSets');

        const headers: HttpHeaders = {
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<JsonMessage>({
            url: '/api/language/default-syn-sets/{organisationId}/{kbId}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)),
            method: 'PUT',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Delete all synonyms for a given org/kb
     * Delete All Synonyms
     */
    deleteAllSynonyms({ organisationId, kbId, sessionId, aPIVersion }: DeleteAllSynonymsRequest): Observable<JsonMessage>
    deleteAllSynonyms({ organisationId, kbId, sessionId, aPIVersion }: DeleteAllSynonymsRequest, opts?: OperationOpts): Observable<AjaxResponse<JsonMessage>>
    deleteAllSynonyms({ organisationId, kbId, sessionId, aPIVersion }: DeleteAllSynonymsRequest, opts?: OperationOpts): Observable<JsonMessage | AjaxResponse<JsonMessage>> {
        throwIfNullOrUndefined(organisationId, 'organisationId', 'deleteAllSynonyms');
        throwIfNullOrUndefined(kbId, 'kbId', 'deleteAllSynonyms');
        throwIfNullOrUndefined(sessionId, 'sessionId', 'deleteAllSynonyms');

        const headers: HttpHeaders = {
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<JsonMessage>({
            url: '/api/language/delete-all-synonyms/{organisationId}/{kbId}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)),
            method: 'DELETE',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * remove a specific categorization for a given org/kb
     * remove categorization
     */
    deleteCategorization({ organisationId, kbId, categorizationLabel, sessionId, aPIVersion }: DeleteCategorizationRequest): Observable<JsonMessage>
    deleteCategorization({ organisationId, kbId, categorizationLabel, sessionId, aPIVersion }: DeleteCategorizationRequest, opts?: OperationOpts): Observable<AjaxResponse<JsonMessage>>
    deleteCategorization({ organisationId, kbId, categorizationLabel, sessionId, aPIVersion }: DeleteCategorizationRequest, opts?: OperationOpts): Observable<JsonMessage | AjaxResponse<JsonMessage>> {
        throwIfNullOrUndefined(organisationId, 'organisationId', 'deleteCategorization');
        throwIfNullOrUndefined(kbId, 'kbId', 'deleteCategorization');
        throwIfNullOrUndefined(categorizationLabel, 'categorizationLabel', 'deleteCategorization');
        throwIfNullOrUndefined(sessionId, 'sessionId', 'deleteCategorization');

        const headers: HttpHeaders = {
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<JsonMessage>({
            url: '/api/language/categorization/{organisationId}/{kbId}/{categorizationLabel}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)).replace('{categorizationLabel}', encodeURI(categorizationLabel)),
            method: 'DELETE',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Remove an existing semantic from SimSage.
     * Delete Semantic
     */
    deleteSemantic({ organisationId, kbId, word, semantic, sessionId, aPIVersion }: DeleteSemanticRequest): Observable<JsonMessage>
    deleteSemantic({ organisationId, kbId, word, semantic, sessionId, aPIVersion }: DeleteSemanticRequest, opts?: OperationOpts): Observable<AjaxResponse<JsonMessage>>
    deleteSemantic({ organisationId, kbId, word, semantic, sessionId, aPIVersion }: DeleteSemanticRequest, opts?: OperationOpts): Observable<JsonMessage | AjaxResponse<JsonMessage>> {
        throwIfNullOrUndefined(organisationId, 'organisationId', 'deleteSemantic');
        throwIfNullOrUndefined(kbId, 'kbId', 'deleteSemantic');
        throwIfNullOrUndefined(word, 'word', 'deleteSemantic');
        throwIfNullOrUndefined(semantic, 'semantic', 'deleteSemantic');
        throwIfNullOrUndefined(sessionId, 'sessionId', 'deleteSemantic');

        const headers: HttpHeaders = {
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<JsonMessage>({
            url: '/api/language/delete-semantic/{organisationId}/{kbId}/{word}/{semantic}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)).replace('{word}', encodeURI(word)).replace('{semantic}', encodeURI(semantic)),
            method: 'DELETE',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Remove a syn-set from SimSage by lemma.
     * Delete SynSet
     */
    deleteSynSet({ organisationId, kbId, lemma, sessionId, aPIVersion }: DeleteSynSetRequest): Observable<JsonMessage>
    deleteSynSet({ organisationId, kbId, lemma, sessionId, aPIVersion }: DeleteSynSetRequest, opts?: OperationOpts): Observable<AjaxResponse<JsonMessage>>
    deleteSynSet({ organisationId, kbId, lemma, sessionId, aPIVersion }: DeleteSynSetRequest, opts?: OperationOpts): Observable<JsonMessage | AjaxResponse<JsonMessage>> {
        throwIfNullOrUndefined(organisationId, 'organisationId', 'deleteSynSet');
        throwIfNullOrUndefined(kbId, 'kbId', 'deleteSynSet');
        throwIfNullOrUndefined(lemma, 'lemma', 'deleteSynSet');
        throwIfNullOrUndefined(sessionId, 'sessionId', 'deleteSynSet');

        const headers: HttpHeaders = {
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<JsonMessage>({
            url: '/api/language/delete-syn-set/{organisationId}/{kbId}/{lemma}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)).replace('{lemma}', encodeURI(lemma)),
            method: 'DELETE',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Delete a synonym using its id.
     * Delete Synonym
     */
    deleteSynonym({ organisationId, kbId, id, sessionId, aPIVersion }: DeleteSynonymRequest): Observable<JsonMessage>
    deleteSynonym({ organisationId, kbId, id, sessionId, aPIVersion }: DeleteSynonymRequest, opts?: OperationOpts): Observable<AjaxResponse<JsonMessage>>
    deleteSynonym({ organisationId, kbId, id, sessionId, aPIVersion }: DeleteSynonymRequest, opts?: OperationOpts): Observable<JsonMessage | AjaxResponse<JsonMessage>> {
        throwIfNullOrUndefined(organisationId, 'organisationId', 'deleteSynonym');
        throwIfNullOrUndefined(kbId, 'kbId', 'deleteSynonym');
        throwIfNullOrUndefined(id, 'id', 'deleteSynonym');
        throwIfNullOrUndefined(sessionId, 'sessionId', 'deleteSynonym');

        const headers: HttpHeaders = {
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<JsonMessage>({
            url: '/api/language/delete-synonym/{organisationId}/{kbId}/{id}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)).replace('{id}', encodeURI(id)),
            method: 'DELETE',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Find syn-sets using filters
     * Find SynSets
     */
    findSynSets({ sessionId, cMSynSetFind, aPIVersion }: FindSynSetsRequest): Observable<CMSynSetList>
    findSynSets({ sessionId, cMSynSetFind, aPIVersion }: FindSynSetsRequest, opts?: OperationOpts): Observable<AjaxResponse<CMSynSetList>>
    findSynSets({ sessionId, cMSynSetFind, aPIVersion }: FindSynSetsRequest, opts?: OperationOpts): Observable<CMSynSetList | AjaxResponse<CMSynSetList>> {
        throwIfNullOrUndefined(sessionId, 'sessionId', 'findSynSets');
        throwIfNullOrUndefined(cMSynSetFind, 'cMSynSetFind', 'findSynSets');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<CMSynSetList>({
            url: '/api/language/find-syn-sets',
            method: 'PUT',
            headers,
            body: cMSynSetFind,
        }, opts?.responseOpts);
    };

    /**
     * get all categorizations for a given org/kb paginated
     * categorization list
     */
    getCategorizationList({ organisationId, kbId, prevCategorizationLabel, pageSize, sessionId, aPIVersion }: GetCategorizationListRequest): Observable<CMCategorizationPaginatedList>
    getCategorizationList({ organisationId, kbId, prevCategorizationLabel, pageSize, sessionId, aPIVersion }: GetCategorizationListRequest, opts?: OperationOpts): Observable<AjaxResponse<CMCategorizationPaginatedList>>
    getCategorizationList({ organisationId, kbId, prevCategorizationLabel, pageSize, sessionId, aPIVersion }: GetCategorizationListRequest, opts?: OperationOpts): Observable<CMCategorizationPaginatedList | AjaxResponse<CMCategorizationPaginatedList>> {
        throwIfNullOrUndefined(organisationId, 'organisationId', 'getCategorizationList');
        throwIfNullOrUndefined(kbId, 'kbId', 'getCategorizationList');
        throwIfNullOrUndefined(prevCategorizationLabel, 'prevCategorizationLabel', 'getCategorizationList');
        throwIfNullOrUndefined(pageSize, 'pageSize', 'getCategorizationList');
        throwIfNullOrUndefined(sessionId, 'sessionId', 'getCategorizationList');

        const headers: HttpHeaders = {
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<CMCategorizationPaginatedList>({
            url: '/api/language/categorization/{organisationId}/{kbId}/{prevCategorizationLabel}/{pageSize}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)).replace('{prevCategorizationLabel}', encodeURI(prevCategorizationLabel)).replace('{pageSize}', encodeURI(pageSize)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * return a paginated list of synonyms with optional filtering.
     * get Synonyms Paginated
     */
    getPaginated({ sessionId, cMSynonymsPaginated, aPIVersion }: GetPaginatedRequest): Observable<CMSynonymsPaginatedResult>
    getPaginated({ sessionId, cMSynonymsPaginated, aPIVersion }: GetPaginatedRequest, opts?: OperationOpts): Observable<AjaxResponse<CMSynonymsPaginatedResult>>
    getPaginated({ sessionId, cMSynonymsPaginated, aPIVersion }: GetPaginatedRequest, opts?: OperationOpts): Observable<CMSynonymsPaginatedResult | AjaxResponse<CMSynonymsPaginatedResult>> {
        throwIfNullOrUndefined(sessionId, 'sessionId', 'getPaginated');
        throwIfNullOrUndefined(cMSynonymsPaginated, 'cMSynonymsPaginated', 'getPaginated');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<CMSynonymsPaginatedResult>({
            url: '/api/language/synonyms',
            method: 'PUT',
            headers,
            body: cMSynonymsPaginated,
        }, opts?.responseOpts);
    };

    /**
     * Return a paginated list of semantics with an optional filter.
     * Semantics Paginated
     */
    getSemanticsPaginated({ sessionId, cMSemanticsPaginated, aPIVersion }: GetSemanticsPaginatedRequest): Observable<CMSemanticsPaginatedResult>
    getSemanticsPaginated({ sessionId, cMSemanticsPaginated, aPIVersion }: GetSemanticsPaginatedRequest, opts?: OperationOpts): Observable<AjaxResponse<CMSemanticsPaginatedResult>>
    getSemanticsPaginated({ sessionId, cMSemanticsPaginated, aPIVersion }: GetSemanticsPaginatedRequest, opts?: OperationOpts): Observable<CMSemanticsPaginatedResult | AjaxResponse<CMSemanticsPaginatedResult>> {
        throwIfNullOrUndefined(sessionId, 'sessionId', 'getSemanticsPaginated');
        throwIfNullOrUndefined(cMSemanticsPaginated, 'cMSemanticsPaginated', 'getSemanticsPaginated');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<CMSemanticsPaginatedResult>({
            url: '/api/language/semantics',
            method: 'PUT',
            headers,
            body: cMSemanticsPaginated,
        }, opts?.responseOpts);
    };

    /**
     * Force index optimization for a the given knowledge-base, now.
     * Optimize Indexes
     */
    optimizeIndexes({ sessionId, cMOptimizeIndex, aPIVersion }: OptimizeIndexesRequest): Observable<JsonMessage>
    optimizeIndexes({ sessionId, cMOptimizeIndex, aPIVersion }: OptimizeIndexesRequest, opts?: OperationOpts): Observable<AjaxResponse<JsonMessage>>
    optimizeIndexes({ sessionId, cMOptimizeIndex, aPIVersion }: OptimizeIndexesRequest, opts?: OperationOpts): Observable<JsonMessage | AjaxResponse<JsonMessage>> {
        throwIfNullOrUndefined(sessionId, 'sessionId', 'optimizeIndexes');
        throwIfNullOrUndefined(cMOptimizeIndex, 'cMOptimizeIndex', 'optimizeIndexes');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<JsonMessage>({
            url: '/api/language/optimize-indexes',
            method: 'PUT',
            headers,
            body: cMOptimizeIndex,
        }, opts?.responseOpts);
    };

    /**
     * Create a redacted version of a document as a PDF given its url.
     * Redact Document
     */
    redactDocument({ organisationId, kbId, url, entityCsv, wordCsv, allowWordsCsv, sessionId }: RedactDocumentRequest): Observable<string>
    redactDocument({ organisationId, kbId, url, entityCsv, wordCsv, allowWordsCsv, sessionId }: RedactDocumentRequest, opts?: OperationOpts): Observable<AjaxResponse<string>>
    redactDocument({ organisationId, kbId, url, entityCsv, wordCsv, allowWordsCsv, sessionId }: RedactDocumentRequest, opts?: OperationOpts): Observable<string | AjaxResponse<string>> {
        throwIfNullOrUndefined(organisationId, 'organisationId', 'redactDocument');
        throwIfNullOrUndefined(kbId, 'kbId', 'redactDocument');
        throwIfNullOrUndefined(url, 'url', 'redactDocument');
        throwIfNullOrUndefined(entityCsv, 'entityCsv', 'redactDocument');
        throwIfNullOrUndefined(wordCsv, 'wordCsv', 'redactDocument');
        throwIfNullOrUndefined(allowWordsCsv, 'allowWordsCsv', 'redactDocument');

        const headers: HttpHeaders = {
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
        };

        return this.request<string>({
            url: '/api/language/redact/{organisationId}/{kbId}/{url}/{entityCsv}/{wordCsv}/{allowWordsCsv}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)).replace('{url}', encodeURI(url)).replace('{entityCsv}', encodeURI(entityCsv)).replace('{wordCsv}', encodeURI(wordCsv)).replace('{allowWordsCsv}', encodeURI(allowWordsCsv)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * create or update a specific categorization for a given org/kb
     * save categorization
     */
    saveCategorization({ sessionId, cMCategorization, aPIVersion }: SaveCategorizationRequest): Observable<JsonMessage>
    saveCategorization({ sessionId, cMCategorization, aPIVersion }: SaveCategorizationRequest, opts?: OperationOpts): Observable<AjaxResponse<JsonMessage>>
    saveCategorization({ sessionId, cMCategorization, aPIVersion }: SaveCategorizationRequest, opts?: OperationOpts): Observable<JsonMessage | AjaxResponse<JsonMessage>> {
        throwIfNullOrUndefined(sessionId, 'sessionId', 'saveCategorization');
        throwIfNullOrUndefined(cMCategorization, 'cMCategorization', 'saveCategorization');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<JsonMessage>({
            url: '/api/language/categorization',
            method: 'PUT',
            headers,
            body: cMCategorization,
        }, opts?.responseOpts);
    };

    /**
     * Create or update (save) a semantic in SimSage.
     * Save Semantic
     */
    saveSemantic({ organisationId, kbId, sessionId, cMSemanticModelEdit, aPIVersion }: SaveSemanticRequest): Observable<JsonMessage>
    saveSemantic({ organisationId, kbId, sessionId, cMSemanticModelEdit, aPIVersion }: SaveSemanticRequest, opts?: OperationOpts): Observable<AjaxResponse<JsonMessage>>
    saveSemantic({ organisationId, kbId, sessionId, cMSemanticModelEdit, aPIVersion }: SaveSemanticRequest, opts?: OperationOpts): Observable<JsonMessage | AjaxResponse<JsonMessage>> {
        throwIfNullOrUndefined(organisationId, 'organisationId', 'saveSemantic');
        throwIfNullOrUndefined(kbId, 'kbId', 'saveSemantic');
        throwIfNullOrUndefined(sessionId, 'sessionId', 'saveSemantic');
        throwIfNullOrUndefined(cMSemanticModelEdit, 'cMSemanticModelEdit', 'saveSemantic');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<JsonMessage>({
            url: '/api/language/save-semantic/{organisationId}/{kbId}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)),
            method: 'PUT',
            headers,
            body: cMSemanticModelEdit,
        }, opts?.responseOpts);
    };

    /**
     * Save (update/create) a syn-set in SimSage.
     * Save SynSet
     */
    saveSynSet({ organisationId, kbId, sessionId, cMSynSet, aPIVersion }: SaveSynSetRequest): Observable<JsonMessage>
    saveSynSet({ organisationId, kbId, sessionId, cMSynSet, aPIVersion }: SaveSynSetRequest, opts?: OperationOpts): Observable<AjaxResponse<JsonMessage>>
    saveSynSet({ organisationId, kbId, sessionId, cMSynSet, aPIVersion }: SaveSynSetRequest, opts?: OperationOpts): Observable<JsonMessage | AjaxResponse<JsonMessage>> {
        throwIfNullOrUndefined(organisationId, 'organisationId', 'saveSynSet');
        throwIfNullOrUndefined(kbId, 'kbId', 'saveSynSet');
        throwIfNullOrUndefined(sessionId, 'sessionId', 'saveSynSet');
        throwIfNullOrUndefined(cMSynSet, 'cMSynSet', 'saveSynSet');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<JsonMessage>({
            url: '/api/language/save-syn-set/{organisationId}/{kbId}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)),
            method: 'PUT',
            headers,
            body: cMSynSet,
        }, opts?.responseOpts);
    };

    /**
     * Save (update/create) a synonym.
     * Save Synonym
     */
    saveSynonym({ organisationId, kbId, sessionId, cMSynonym, aPIVersion }: SaveSynonymRequest): Observable<JsonMessage>
    saveSynonym({ organisationId, kbId, sessionId, cMSynonym, aPIVersion }: SaveSynonymRequest, opts?: OperationOpts): Observable<AjaxResponse<JsonMessage>>
    saveSynonym({ organisationId, kbId, sessionId, cMSynonym, aPIVersion }: SaveSynonymRequest, opts?: OperationOpts): Observable<JsonMessage | AjaxResponse<JsonMessage>> {
        throwIfNullOrUndefined(organisationId, 'organisationId', 'saveSynonym');
        throwIfNullOrUndefined(kbId, 'kbId', 'saveSynonym');
        throwIfNullOrUndefined(sessionId, 'sessionId', 'saveSynonym');
        throwIfNullOrUndefined(cMSynonym, 'cMSynonym', 'saveSynonym');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<JsonMessage>({
            url: '/api/language/save-synonym/{organisationId}/{kbId}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)),
            method: 'PUT',
            headers,
            body: cMSynonym,
        }, opts?.responseOpts);
    };

    /**
     * Create a tuned language graph for a given organisation/knowledge-base.
     * Tune Graph
     */
    tuneLanguageGraph({ organisationId, kbId, sessionId, aPIVersion }: TuneLanguageGraphRequest): Observable<JsonMessage>
    tuneLanguageGraph({ organisationId, kbId, sessionId, aPIVersion }: TuneLanguageGraphRequest, opts?: OperationOpts): Observable<AjaxResponse<JsonMessage>>
    tuneLanguageGraph({ organisationId, kbId, sessionId, aPIVersion }: TuneLanguageGraphRequest, opts?: OperationOpts): Observable<JsonMessage | AjaxResponse<JsonMessage>> {
        throwIfNullOrUndefined(organisationId, 'organisationId', 'tuneLanguageGraph');
        throwIfNullOrUndefined(kbId, 'kbId', 'tuneLanguageGraph');
        throwIfNullOrUndefined(sessionId, 'sessionId', 'tuneLanguageGraph');

        const headers: HttpHeaders = {
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<JsonMessage>({
            url: '/api/language/tune-graph/{organisationId}/{kbId}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Return the version of the SimSage Language Services.
     * Version
     */
    version2(): Observable<CMVersion>
    version2(opts?: OperationOpts): Observable<AjaxResponse<CMVersion>>
    version2(opts?: OperationOpts): Observable<CMVersion | AjaxResponse<CMVersion>> {
        return this.request<CMVersion>({
            url: '/api/language/version',
            method: 'GET',
        }, opts?.responseOpts);
    };

}

/**
 * @export
 * @enum {string}
 */
export enum AddDefaultSynSetsAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum DeleteAllSynonymsAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum DeleteCategorizationAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum DeleteSemanticAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum DeleteSynSetAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum DeleteSynonymAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum FindSynSetsAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum GetCategorizationListAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum GetPaginatedAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum GetSemanticsPaginatedAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum OptimizeIndexesAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum SaveCategorizationAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum SaveSemanticAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum SaveSynSetAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum SaveSynonymAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum TuneLanguageGraphAPIVersionEnum {
    _1 = '1'
}
