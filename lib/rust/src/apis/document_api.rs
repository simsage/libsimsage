/*
 * SimSage REST API
 *
 * SimSage REST API
 *
 * The version of the OpenAPI document: 7.12.19
 * Contact: info@simsage.co.uk
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DocumentError {
    Status500(crate::models::JsonMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_parquet_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetParquetFileError {
    Status500(crate::models::JsonMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_parquet_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetParquetListError {
    Status500(crate::models::JsonMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_spreadsheet`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSpreadsheetError {
    Status500(crate::models::JsonMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_stats1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetStats1Error {
    Status500(crate::models::JsonMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`inventorize_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InventorizeDocumentsError {
    Status500(crate::models::JsonMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`inventorize_indexes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InventorizeIndexesError {
    Status500(crate::models::JsonMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`preview`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PreviewError {
    Status500(crate::models::JsonMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`preview_html`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PreviewHtmlError {
    Status500(crate::models::JsonMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`query_focussed_summarization`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueryFocussedSummarizationError {
    Status500(crate::models::JsonMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveDocumentError {
    Status500(crate::models::JsonMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_parquet_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveParquetFileError {
    Status500(crate::models::JsonMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`summarize_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SummarizeDocumentError {
    Status500(crate::models::JsonMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`version4`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Version4Error {
    Status500(crate::models::JsonMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`zip_source`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ZipSourceError {
    Status500(crate::models::JsonMessage),
    UnknownValue(serde_json::Value),
}


/// return a document's details given a base64 encoded url
pub async fn document(configuration: &configuration::Configuration, session_id: &str, organisation_id: &str, kb_id: &str, url: &str) -> Result<crate::models::CmDocument, Error<DocumentError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/document/document/{organisationId}/{kbId}/{url}", local_var_configuration.base_path, organisationId=crate::apis::urlencode(organisation_id), kbId=crate::apis::urlencode(kb_id), url=crate::apis::urlencode(url));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("session-id", session_id.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DocumentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Download an inventory parquet file.
pub async fn get_parquet_file(configuration: &configuration::Configuration, ott: &str, organisation_id: &str, kb_id: &str, date_time: i64) -> Result<String, Error<GetParquetFileError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/document/parquet/{organisationId}/{kbId}/{dateTime}", local_var_configuration.base_path, organisationId=crate::apis::urlencode(organisation_id), kbId=crate::apis::urlencode(kb_id), dateTime=date_time);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("ott", &ott.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetParquetFileError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Return a list of inventory times available for download.
pub async fn get_parquet_list(configuration: &configuration::Configuration, organisation_id: &str, kb_id: &str, page: i32, page_size: i32, session_id: &str, api_version: Option<&str>) -> Result<crate::models::CmParquetTimeList, Error<GetParquetListError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/document/parquets/{organisationId}/{kbId}/{page}/{pageSize}", local_var_configuration.base_path, organisationId=crate::apis::urlencode(organisation_id), kbId=crate::apis::urlencode(kb_id), page=page, pageSize=page_size);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("session-id", session_id.to_string());
    if let Some(local_var_param_value) = api_version {
        local_var_req_builder = local_var_req_builder.header("API-Version", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetParquetListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Download an inventory breakdown spreadsheet for a given date-time.
pub async fn get_spreadsheet(configuration: &configuration::Configuration, ott: &str, organisation_id: &str, kb_id: &str, date_time: i64) -> Result<String, Error<GetSpreadsheetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/document/spreadsheet/{organisationId}/{kbId}/{dateTime}", local_var_configuration.base_path, organisationId=crate::apis::urlencode(organisation_id), kbId=crate::apis::urlencode(kb_id), dateTime=date_time);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("ott", &ott.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSpreadsheetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Return a document frequency statistics report - frequencies of different document types
pub async fn get_stats1(configuration: &configuration::Configuration, ott: &str, organisation_id: &str, kb_id: &str, date_time: i64) -> Result<Vec<crate::models::CmDocumentTypeFrequency>, Error<GetStats1Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/document/stats/frequencies/{organisationId}/{kbId}/{dateTime}", local_var_configuration.base_path, organisationId=crate::apis::urlencode(organisation_id), kbId=crate::apis::urlencode(kb_id), dateTime=date_time);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("ott", &ott.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetStats1Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Start the async inventorize process for documents of a given organisation/kb.
pub async fn inventorize_documents(configuration: &configuration::Configuration, session_id: &str, cm_inventorize_parameters: crate::models::CmInventorizeParameters, api_version: Option<&str>) -> Result<crate::models::JsonMessage, Error<InventorizeDocumentsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/document/inventorize", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("session-id", session_id.to_string());
    if let Some(local_var_param_value) = api_version {
        local_var_req_builder = local_var_req_builder.header("API-Version", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&cm_inventorize_parameters);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<InventorizeDocumentsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Start the async inventorize process for the optimized-indexes of a given organisation/kb.
pub async fn inventorize_indexes(configuration: &configuration::Configuration, session_id: &str, cm_inventorize_parameters: crate::models::CmInventorizeParameters, api_version: Option<&str>) -> Result<crate::models::JsonMessage, Error<InventorizeIndexesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/document/inventorize-indexes", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("session-id", session_id.to_string());
    if let Some(local_var_param_value) = api_version {
        local_var_req_builder = local_var_req_builder.header("API-Version", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&cm_inventorize_parameters);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<InventorizeIndexesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// get a preview for a document if available by url
pub async fn preview(configuration: &configuration::Configuration, organisation_id: &str, kb_id: &str, client_id: &str, session_id: &str, url_id: i32, page: i32) -> Result<String, Error<PreviewError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/document/preview/{organisationId}/{kbId}/{clientId}/{sessionId}/{urlId}/{page}", local_var_configuration.base_path, organisationId=crate::apis::urlencode(organisation_id), kbId=crate::apis::urlencode(kb_id), clientId=crate::apis::urlencode(client_id), sessionId=crate::apis::urlencode(session_id), urlId=url_id, page=page);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PreviewError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// get a preview HTML page for a document if available by url
pub async fn preview_html(configuration: &configuration::Configuration, session_id: &str, cm_get_html: crate::models::CmGetHtml) -> Result<crate::models::CmGetHtml, Error<PreviewHtmlError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/document/preview/html", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("session-id", session_id.to_string());
    local_var_req_builder = local_var_req_builder.json(&cm_get_html);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PreviewHtmlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Summarize a set of documents given a list of urls and a query.
pub async fn query_focussed_summarization(configuration: &configuration::Configuration, session_id: &str, cm_query_focussed_summarization_request: crate::models::CmQueryFocussedSummarizationRequest, api_version: Option<&str>) -> Result<crate::models::CmQueryFocussedSummarization, Error<QueryFocussedSummarizationError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/document/qfs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("session-id", session_id.to_string());
    if let Some(local_var_param_value) = api_version {
        local_var_req_builder = local_var_req_builder.header("API-Version", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&cm_query_focussed_summarization_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<QueryFocussedSummarizationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove/delete a document by its url.
pub async fn remove_document(configuration: &configuration::Configuration, organisation_id: &str, kb_id: &str, url: &str, source_id: i32, session_id: &str, api_version: Option<&str>) -> Result<crate::models::JsonMessage, Error<RemoveDocumentError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/document/document/{organisationId}/{kbId}/{url}/{sourceId}", local_var_configuration.base_path, organisationId=crate::apis::urlencode(organisation_id), kbId=crate::apis::urlencode(kb_id), url=crate::apis::urlencode(url), sourceId=source_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("session-id", session_id.to_string());
    if let Some(local_var_param_value) = api_version {
        local_var_req_builder = local_var_req_builder.header("API-Version", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RemoveDocumentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove an inventory breakdown spreadsheet/parquet file from the system
pub async fn remove_parquet_file(configuration: &configuration::Configuration, organisation_id: &str, kb_id: &str, date_time: i64, session_id: &str, api_version: Option<&str>) -> Result<Vec<crate::models::JsonMessage>, Error<RemoveParquetFileError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/document/parquet/{organisationId}/{kbId}/{dateTime}", local_var_configuration.base_path, organisationId=crate::apis::urlencode(organisation_id), kbId=crate::apis::urlencode(kb_id), dateTime=date_time);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("session-id", session_id.to_string());
    if let Some(local_var_param_value) = api_version {
        local_var_req_builder = local_var_req_builder.header("API-Version", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RemoveParquetFileError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Summarize a single document using an extractive summarization.
pub async fn summarize_document(configuration: &configuration::Configuration, session_id: &str, cm_single_document_summary_request: crate::models::CmSingleDocumentSummaryRequest, api_version: Option<&str>) -> Result<crate::models::CmSingleDocumentSummary, Error<SummarizeDocumentError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/document/summarize/document", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("session-id", session_id.to_string());
    if let Some(local_var_param_value) = api_version {
        local_var_req_builder = local_var_req_builder.header("API-Version", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&cm_single_document_summary_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SummarizeDocumentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the version of SimSage Document Services.
pub async fn version4(configuration: &configuration::Configuration, ) -> Result<crate::models::CmVersion, Error<Version4Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/document/version", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Version4Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Zip all documents in a source on the local server.
pub async fn zip_source(configuration: &configuration::Configuration, session_id: &str, cm_zip_source: crate::models::CmZipSource, api_version: Option<&str>) -> Result<crate::models::JsonMessage, Error<ZipSourceError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/document/zip/source", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("session-id", session_id.to_string());
    if let Some(local_var_param_value) = api_version {
        local_var_req_builder = local_var_req_builder.header("API-Version", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&cm_zip_source);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ZipSourceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

