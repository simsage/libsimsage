// tslint:disable
/**
 * SimSage REST API
 * SimSage REST API
 *
 * The version of the OpenAPI document: 7.14.12
 * Contact: info@simsage.co.uk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Observable } from 'rxjs';
import type { AjaxResponse } from 'rxjs/ajax';
import { BaseAPI, throwIfNullOrUndefined, encodeURI } from '../runtime';
import type { OperationOpts, HttpHeaders } from '../runtime';
import type {
    CMClientQuery,
    CMClientQueryResult,
    CMDocumentQuestionAndAnswer,
    CMShortSummary,
    CMShortSummaryResult,
    CMTextToSearchConversion,
    CMTextToSearchConversionReturn,
    CMTextToSearchEdit,
    CMTextToSearchPaginated,
    CMTextToSearchPaginatedReturn,
    CMVersion,
    JsonMessage,
} from '../models';

export interface DeleteTextToSearchRequest {
    organisationId: string;
    kbId: string;
    word: string;
    sessionId: string;
    aPIVersion?: DeleteTextToSearchAPIVersionEnum;
}

export interface DocumentQuestionAndAnswerRequest {
    sessionId: string;
    cMDocumentQuestionAndAnswer: CMDocumentQuestionAndAnswer;
}

export interface GetTextToSearchPaginatedRequest {
    sessionId: string;
    cMTextToSearchPaginated: CMTextToSearchPaginated;
    aPIVersion?: GetTextToSearchPaginatedAPIVersionEnum;
}

export interface RestfulClientQueryRequest {
    cMClientQuery: CMClientQuery;
}

export interface SaveTextToSearchRequest {
    organisationId: string;
    kbId: string;
    sessionId: string;
    cMTextToSearchEdit: CMTextToSearchEdit;
    aPIVersion?: SaveTextToSearchAPIVersionEnum;
}

export interface ShortSummaryRequest {
    cMShortSummary: CMShortSummary;
}

export interface TryTextToSearchConversionRequest {
    sessionId: string;
    cMTextToSearchConversion: CMTextToSearchConversion;
    aPIVersion?: TryTextToSearchConversionAPIVersionEnum;
}

/**
 * no description
 */
export class SemanticApi extends BaseAPI {

    /**
     * Remove an existing text-to-search item.
     * Delete text-to-search
     */
    deleteTextToSearch({ organisationId, kbId, word, sessionId, aPIVersion }: DeleteTextToSearchRequest): Observable<JsonMessage>
    deleteTextToSearch({ organisationId, kbId, word, sessionId, aPIVersion }: DeleteTextToSearchRequest, opts?: OperationOpts): Observable<AjaxResponse<JsonMessage>>
    deleteTextToSearch({ organisationId, kbId, word, sessionId, aPIVersion }: DeleteTextToSearchRequest, opts?: OperationOpts): Observable<JsonMessage | AjaxResponse<JsonMessage>> {
        throwIfNullOrUndefined(organisationId, 'organisationId', 'deleteTextToSearch');
        throwIfNullOrUndefined(kbId, 'kbId', 'deleteTextToSearch');
        throwIfNullOrUndefined(word, 'word', 'deleteTextToSearch');
        throwIfNullOrUndefined(sessionId, 'sessionId', 'deleteTextToSearch');

        const headers: HttpHeaders = {
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<JsonMessage>({
            url: '/api/semantic/text-to-search/{organisationId}/{kbId}/{word}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)).replace('{word}', encodeURI(word)),
            method: 'DELETE',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Answer a question about a given document
     * Document Q&A
     */
    documentQuestionAndAnswer({ sessionId, cMDocumentQuestionAndAnswer }: DocumentQuestionAndAnswerRequest): Observable<CMDocumentQuestionAndAnswer>
    documentQuestionAndAnswer({ sessionId, cMDocumentQuestionAndAnswer }: DocumentQuestionAndAnswerRequest, opts?: OperationOpts): Observable<AjaxResponse<CMDocumentQuestionAndAnswer>>
    documentQuestionAndAnswer({ sessionId, cMDocumentQuestionAndAnswer }: DocumentQuestionAndAnswerRequest, opts?: OperationOpts): Observable<CMDocumentQuestionAndAnswer | AjaxResponse<CMDocumentQuestionAndAnswer>> {
        throwIfNullOrUndefined(sessionId, 'sessionId', 'documentQuestionAndAnswer');
        throwIfNullOrUndefined(cMDocumentQuestionAndAnswer, 'cMDocumentQuestionAndAnswer', 'documentQuestionAndAnswer');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
        };

        return this.request<CMDocumentQuestionAndAnswer>({
            url: '/api/semantic/document-qa',
            method: 'POST',
            headers,
            body: cMDocumentQuestionAndAnswer,
        }, opts?.responseOpts);
    };

    /**
     * Return a paginated list of text-to-search mappings with an optional filter.
     * Text to Search mappings
     */
    getTextToSearchPaginated({ sessionId, cMTextToSearchPaginated, aPIVersion }: GetTextToSearchPaginatedRequest): Observable<CMTextToSearchPaginatedReturn>
    getTextToSearchPaginated({ sessionId, cMTextToSearchPaginated, aPIVersion }: GetTextToSearchPaginatedRequest, opts?: OperationOpts): Observable<AjaxResponse<CMTextToSearchPaginatedReturn>>
    getTextToSearchPaginated({ sessionId, cMTextToSearchPaginated, aPIVersion }: GetTextToSearchPaginatedRequest, opts?: OperationOpts): Observable<CMTextToSearchPaginatedReturn | AjaxResponse<CMTextToSearchPaginatedReturn>> {
        throwIfNullOrUndefined(sessionId, 'sessionId', 'getTextToSearchPaginated');
        throwIfNullOrUndefined(cMTextToSearchPaginated, 'cMTextToSearchPaginated', 'getTextToSearchPaginated');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<CMTextToSearchPaginatedReturn>({
            url: '/api/semantic/text-to-search',
            method: 'PUT',
            headers,
            body: cMTextToSearchPaginated,
        }, opts?.responseOpts);
    };

    /**
     * a SimSage client asks a question or performs a keyword-search.
     * Client Query
     */
    restfulClientQuery({ cMClientQuery }: RestfulClientQueryRequest): Observable<CMClientQueryResult>
    restfulClientQuery({ cMClientQuery }: RestfulClientQueryRequest, opts?: OperationOpts): Observable<AjaxResponse<CMClientQueryResult>>
    restfulClientQuery({ cMClientQuery }: RestfulClientQueryRequest, opts?: OperationOpts): Observable<CMClientQueryResult | AjaxResponse<CMClientQueryResult>> {
        throwIfNullOrUndefined(cMClientQuery, 'cMClientQuery', 'restfulClientQuery');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
        };

        return this.request<CMClientQueryResult>({
            url: '/api/semantic/query',
            method: 'POST',
            headers,
            body: cMClientQuery,
        }, opts?.responseOpts);
    };

    /**
     * Create or update (save) a text-to-search item.
     * Save a text-to-search item
     */
    saveTextToSearch({ organisationId, kbId, sessionId, cMTextToSearchEdit, aPIVersion }: SaveTextToSearchRequest): Observable<JsonMessage>
    saveTextToSearch({ organisationId, kbId, sessionId, cMTextToSearchEdit, aPIVersion }: SaveTextToSearchRequest, opts?: OperationOpts): Observable<AjaxResponse<JsonMessage>>
    saveTextToSearch({ organisationId, kbId, sessionId, cMTextToSearchEdit, aPIVersion }: SaveTextToSearchRequest, opts?: OperationOpts): Observable<JsonMessage | AjaxResponse<JsonMessage>> {
        throwIfNullOrUndefined(organisationId, 'organisationId', 'saveTextToSearch');
        throwIfNullOrUndefined(kbId, 'kbId', 'saveTextToSearch');
        throwIfNullOrUndefined(sessionId, 'sessionId', 'saveTextToSearch');
        throwIfNullOrUndefined(cMTextToSearchEdit, 'cMTextToSearchEdit', 'saveTextToSearch');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<JsonMessage>({
            url: '/api/semantic/text-to-search/{organisationId}/{kbId}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)),
            method: 'PUT',
            headers,
            body: cMTextToSearchEdit,
        }, opts?.responseOpts);
    };

    /**
     * Create a short summary for a given url / sentence
     * Short summary
     */
    shortSummary({ cMShortSummary }: ShortSummaryRequest): Observable<CMShortSummaryResult>
    shortSummary({ cMShortSummary }: ShortSummaryRequest, opts?: OperationOpts): Observable<AjaxResponse<CMShortSummaryResult>>
    shortSummary({ cMShortSummary }: ShortSummaryRequest, opts?: OperationOpts): Observable<CMShortSummaryResult | AjaxResponse<CMShortSummaryResult>> {
        throwIfNullOrUndefined(cMShortSummary, 'cMShortSummary', 'shortSummary');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
        };

        return this.request<CMShortSummaryResult>({
            url: '/api/semantic/short-summary',
            method: 'POST',
            headers,
            body: cMShortSummary,
        }, opts?.responseOpts);
    };

    /**
     * See the results of a text-to-search conversion
     * try converting text-to-search
     */
    tryTextToSearchConversion({ sessionId, cMTextToSearchConversion, aPIVersion }: TryTextToSearchConversionRequest): Observable<CMTextToSearchConversionReturn>
    tryTextToSearchConversion({ sessionId, cMTextToSearchConversion, aPIVersion }: TryTextToSearchConversionRequest, opts?: OperationOpts): Observable<AjaxResponse<CMTextToSearchConversionReturn>>
    tryTextToSearchConversion({ sessionId, cMTextToSearchConversion, aPIVersion }: TryTextToSearchConversionRequest, opts?: OperationOpts): Observable<CMTextToSearchConversionReturn | AjaxResponse<CMTextToSearchConversionReturn>> {
        throwIfNullOrUndefined(sessionId, 'sessionId', 'tryTextToSearchConversion');
        throwIfNullOrUndefined(cMTextToSearchConversion, 'cMTextToSearchConversion', 'tryTextToSearchConversion');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<CMTextToSearchConversionReturn>({
            url: '/api/semantic/text-to-search-try',
            method: 'PUT',
            headers,
            body: cMTextToSearchConversion,
        }, opts?.responseOpts);
    };

    /**
     * Get the version of SimSage Search Services.
     * Version
     */
    version1(): Observable<CMVersion>
    version1(opts?: OperationOpts): Observable<AjaxResponse<CMVersion>>
    version1(opts?: OperationOpts): Observable<CMVersion | AjaxResponse<CMVersion>> {
        return this.request<CMVersion>({
            url: '/api/semantic/version',
            method: 'GET',
        }, opts?.responseOpts);
    };

}

/**
 * @export
 * @enum {string}
 */
export enum DeleteTextToSearchAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum GetTextToSearchPaginatedAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum SaveTextToSearchAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum TryTextToSearchConversionAPIVersionEnum {
    _1 = '1'
}
