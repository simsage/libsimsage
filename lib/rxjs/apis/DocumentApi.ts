// tslint:disable
/**
 * SimSage REST API
 * SimSage REST API
 *
 * The version of the OpenAPI document: 7.14.12
 * Contact: info@simsage.co.uk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Observable } from 'rxjs';
import type { AjaxResponse } from 'rxjs/ajax';
import { BaseAPI, throwIfNullOrUndefined, encodeURI } from '../runtime';
import type { OperationOpts, HttpHeaders, HttpQuery } from '../runtime';
import type {
    CMDocument,
    CMDocumentTypeFrequency,
    CMGetHtml,
    CMInventorizeParameters,
    CMParquetTimeList,
    CMQueryFocussedSummarization,
    CMQueryFocussedSummarizationRequest,
    CMSingleDocumentSummary,
    CMSingleDocumentSummaryRequest,
    CMVersion,
    JsonMessage,
} from '../models';

export interface DocumentRequest {
    sessionId: string;
    organisationId: string;
    kbId: string;
    url: string;
}

export interface GetParquetFileRequest {
    ott: string;
    organisationId: string;
    kbId: string;
    dateTime: number;
}

export interface GetParquetListRequest {
    organisationId: string;
    kbId: string;
    page: number;
    pageSize: number;
    sessionId: string;
    aPIVersion?: GetParquetListAPIVersionEnum;
}

export interface GetSpreadsheetRequest {
    ott: string;
    organisationId: string;
    kbId: string;
    dateTime: number;
}

export interface GetStats1Request {
    ott: string;
    organisationId: string;
    kbId: string;
    dateTime: number;
}

export interface InventorizeDocumentsRequest {
    sessionId: string;
    cMInventorizeParameters: CMInventorizeParameters;
    aPIVersion?: InventorizeDocumentsAPIVersionEnum;
}

export interface InventorizeIndexesRequest {
    sessionId: string;
    cMInventorizeParameters: CMInventorizeParameters;
    aPIVersion?: InventorizeIndexesAPIVersionEnum;
}

export interface PreviewRequest {
    organisationId: string;
    kbId: string;
    clientId: string;
    sessionId: string;
    urlId: number;
    page: number;
}

export interface PreviewHtmlRequest {
    sessionId: string;
    cMGetHtml: CMGetHtml;
}

export interface QueryFocussedSummarizationRequest {
    sessionId: string;
    cMQueryFocussedSummarizationRequest: CMQueryFocussedSummarizationRequest;
    aPIVersion?: QueryFocussedSummarizationAPIVersionEnum;
}

export interface RemoveDocumentRequest {
    organisationId: string;
    kbId: string;
    url: string;
    sourceId: number;
    sessionId: string;
    aPIVersion?: RemoveDocumentAPIVersionEnum;
}

export interface RemoveParquetFileRequest {
    organisationId: string;
    kbId: string;
    dateTime: number;
    sessionId: string;
    aPIVersion?: RemoveParquetFileAPIVersionEnum;
}

export interface SummarizeDocumentRequest {
    sessionId: string;
    cMSingleDocumentSummaryRequest: CMSingleDocumentSummaryRequest;
    aPIVersion?: SummarizeDocumentAPIVersionEnum;
}

/**
 * no description
 */
export class DocumentApi extends BaseAPI {

    /**
     * return a document\'s details given a base64 encoded url
     * get Document
     */
    document({ sessionId, organisationId, kbId, url }: DocumentRequest): Observable<CMDocument>
    document({ sessionId, organisationId, kbId, url }: DocumentRequest, opts?: OperationOpts): Observable<AjaxResponse<CMDocument>>
    document({ sessionId, organisationId, kbId, url }: DocumentRequest, opts?: OperationOpts): Observable<CMDocument | AjaxResponse<CMDocument>> {
        throwIfNullOrUndefined(sessionId, 'sessionId', 'document');
        throwIfNullOrUndefined(organisationId, 'organisationId', 'document');
        throwIfNullOrUndefined(kbId, 'kbId', 'document');
        throwIfNullOrUndefined(url, 'url', 'document');

        const headers: HttpHeaders = {
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
        };

        return this.request<CMDocument>({
            url: '/api/document/document/{organisationId}/{kbId}/{url}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)).replace('{url}', encodeURI(url)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Download an inventory parquet file.
     * Download Parquet File
     */
    getParquetFile({ ott, organisationId, kbId, dateTime }: GetParquetFileRequest): Observable<string>
    getParquetFile({ ott, organisationId, kbId, dateTime }: GetParquetFileRequest, opts?: OperationOpts): Observable<AjaxResponse<string>>
    getParquetFile({ ott, organisationId, kbId, dateTime }: GetParquetFileRequest, opts?: OperationOpts): Observable<string | AjaxResponse<string>> {
        throwIfNullOrUndefined(ott, 'ott', 'getParquetFile');
        throwIfNullOrUndefined(organisationId, 'organisationId', 'getParquetFile');
        throwIfNullOrUndefined(kbId, 'kbId', 'getParquetFile');
        throwIfNullOrUndefined(dateTime, 'dateTime', 'getParquetFile');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'ott': ott,
        };

        return this.request<string>({
            url: '/api/document/parquet/{organisationId}/{kbId}/{dateTime}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)).replace('{dateTime}', encodeURI(dateTime)),
            method: 'POST',
            query,
        }, opts?.responseOpts);
    };

    /**
     * Return a list of inventory times available for download.
     * Parquet available time list
     */
    getParquetList({ organisationId, kbId, page, pageSize, sessionId, aPIVersion }: GetParquetListRequest): Observable<CMParquetTimeList>
    getParquetList({ organisationId, kbId, page, pageSize, sessionId, aPIVersion }: GetParquetListRequest, opts?: OperationOpts): Observable<AjaxResponse<CMParquetTimeList>>
    getParquetList({ organisationId, kbId, page, pageSize, sessionId, aPIVersion }: GetParquetListRequest, opts?: OperationOpts): Observable<CMParquetTimeList | AjaxResponse<CMParquetTimeList>> {
        throwIfNullOrUndefined(organisationId, 'organisationId', 'getParquetList');
        throwIfNullOrUndefined(kbId, 'kbId', 'getParquetList');
        throwIfNullOrUndefined(page, 'page', 'getParquetList');
        throwIfNullOrUndefined(pageSize, 'pageSize', 'getParquetList');
        throwIfNullOrUndefined(sessionId, 'sessionId', 'getParquetList');

        const headers: HttpHeaders = {
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<CMParquetTimeList>({
            url: '/api/document/parquets/{organisationId}/{kbId}/{page}/{pageSize}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)).replace('{page}', encodeURI(page)).replace('{pageSize}', encodeURI(pageSize)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Download an inventory breakdown spreadsheet for a given date-time.
     * Inventory breakdown Spreadsheet
     */
    getSpreadsheet({ ott, organisationId, kbId, dateTime }: GetSpreadsheetRequest): Observable<string>
    getSpreadsheet({ ott, organisationId, kbId, dateTime }: GetSpreadsheetRequest, opts?: OperationOpts): Observable<AjaxResponse<string>>
    getSpreadsheet({ ott, organisationId, kbId, dateTime }: GetSpreadsheetRequest, opts?: OperationOpts): Observable<string | AjaxResponse<string>> {
        throwIfNullOrUndefined(ott, 'ott', 'getSpreadsheet');
        throwIfNullOrUndefined(organisationId, 'organisationId', 'getSpreadsheet');
        throwIfNullOrUndefined(kbId, 'kbId', 'getSpreadsheet');
        throwIfNullOrUndefined(dateTime, 'dateTime', 'getSpreadsheet');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'ott': ott,
        };

        return this.request<string>({
            url: '/api/document/spreadsheet/{organisationId}/{kbId}/{dateTime}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)).replace('{dateTime}', encodeURI(dateTime)),
            method: 'POST',
            query,
        }, opts?.responseOpts);
    };

    /**
     * Return a document frequency statistics report - frequencies of different document types
     * Document Frequency Statistics
     */
    getStats1({ ott, organisationId, kbId, dateTime }: GetStats1Request): Observable<Array<CMDocumentTypeFrequency>>
    getStats1({ ott, organisationId, kbId, dateTime }: GetStats1Request, opts?: OperationOpts): Observable<AjaxResponse<Array<CMDocumentTypeFrequency>>>
    getStats1({ ott, organisationId, kbId, dateTime }: GetStats1Request, opts?: OperationOpts): Observable<Array<CMDocumentTypeFrequency> | AjaxResponse<Array<CMDocumentTypeFrequency>>> {
        throwIfNullOrUndefined(ott, 'ott', 'getStats1');
        throwIfNullOrUndefined(organisationId, 'organisationId', 'getStats1');
        throwIfNullOrUndefined(kbId, 'kbId', 'getStats1');
        throwIfNullOrUndefined(dateTime, 'dateTime', 'getStats1');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'ott': ott,
        };

        return this.request<Array<CMDocumentTypeFrequency>>({
            url: '/api/document/stats/frequencies/{organisationId}/{kbId}/{dateTime}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)).replace('{dateTime}', encodeURI(dateTime)),
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     * Start the async inventorize process for documents of a given organisation/kb.
     * Document Inventory
     */
    inventorizeDocuments({ sessionId, cMInventorizeParameters, aPIVersion }: InventorizeDocumentsRequest): Observable<JsonMessage>
    inventorizeDocuments({ sessionId, cMInventorizeParameters, aPIVersion }: InventorizeDocumentsRequest, opts?: OperationOpts): Observable<AjaxResponse<JsonMessage>>
    inventorizeDocuments({ sessionId, cMInventorizeParameters, aPIVersion }: InventorizeDocumentsRequest, opts?: OperationOpts): Observable<JsonMessage | AjaxResponse<JsonMessage>> {
        throwIfNullOrUndefined(sessionId, 'sessionId', 'inventorizeDocuments');
        throwIfNullOrUndefined(cMInventorizeParameters, 'cMInventorizeParameters', 'inventorizeDocuments');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<JsonMessage>({
            url: '/api/document/inventorize',
            method: 'POST',
            headers,
            body: cMInventorizeParameters,
        }, opts?.responseOpts);
    };

    /**
     * Start the async inventorize process for the optimized-indexes of a given organisation/kb.
     * Index Inventory
     */
    inventorizeIndexes({ sessionId, cMInventorizeParameters, aPIVersion }: InventorizeIndexesRequest): Observable<JsonMessage>
    inventorizeIndexes({ sessionId, cMInventorizeParameters, aPIVersion }: InventorizeIndexesRequest, opts?: OperationOpts): Observable<AjaxResponse<JsonMessage>>
    inventorizeIndexes({ sessionId, cMInventorizeParameters, aPIVersion }: InventorizeIndexesRequest, opts?: OperationOpts): Observable<JsonMessage | AjaxResponse<JsonMessage>> {
        throwIfNullOrUndefined(sessionId, 'sessionId', 'inventorizeIndexes');
        throwIfNullOrUndefined(cMInventorizeParameters, 'cMInventorizeParameters', 'inventorizeIndexes');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<JsonMessage>({
            url: '/api/document/inventorize-indexes',
            method: 'POST',
            headers,
            body: cMInventorizeParameters,
        }, opts?.responseOpts);
    };

    /**
     * get a preview for a document if available by url
     * get Preview
     */
    preview({ organisationId, kbId, clientId, sessionId, urlId, page }: PreviewRequest): Observable<string>
    preview({ organisationId, kbId, clientId, sessionId, urlId, page }: PreviewRequest, opts?: OperationOpts): Observable<AjaxResponse<string>>
    preview({ organisationId, kbId, clientId, sessionId, urlId, page }: PreviewRequest, opts?: OperationOpts): Observable<string | AjaxResponse<string>> {
        throwIfNullOrUndefined(organisationId, 'organisationId', 'preview');
        throwIfNullOrUndefined(kbId, 'kbId', 'preview');
        throwIfNullOrUndefined(clientId, 'clientId', 'preview');
        throwIfNullOrUndefined(sessionId, 'sessionId', 'preview');
        throwIfNullOrUndefined(urlId, 'urlId', 'preview');
        throwIfNullOrUndefined(page, 'page', 'preview');

        return this.request<string>({
            url: '/api/document/preview/{organisationId}/{kbId}/{clientId}/{sessionId}/{urlId}/{page}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)).replace('{clientId}', encodeURI(clientId)).replace('{sessionId}', encodeURI(sessionId)).replace('{urlId}', encodeURI(urlId)).replace('{page}', encodeURI(page)),
            method: 'GET',
        }, opts?.responseOpts);
    };

    /**
     * get a preview HTML page for a document if available by url
     * Preview HTML
     */
    previewHtml({ sessionId, cMGetHtml }: PreviewHtmlRequest): Observable<CMGetHtml>
    previewHtml({ sessionId, cMGetHtml }: PreviewHtmlRequest, opts?: OperationOpts): Observable<AjaxResponse<CMGetHtml>>
    previewHtml({ sessionId, cMGetHtml }: PreviewHtmlRequest, opts?: OperationOpts): Observable<CMGetHtml | AjaxResponse<CMGetHtml>> {
        throwIfNullOrUndefined(sessionId, 'sessionId', 'previewHtml');
        throwIfNullOrUndefined(cMGetHtml, 'cMGetHtml', 'previewHtml');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
        };

        return this.request<CMGetHtml>({
            url: '/api/document/preview/html',
            method: 'POST',
            headers,
            body: cMGetHtml,
        }, opts?.responseOpts);
    };

    /**
     * Summarize a set of documents given a list of urls and a query.
     * Summarize Documents for Query
     */
    queryFocussedSummarization({ sessionId, cMQueryFocussedSummarizationRequest, aPIVersion }: QueryFocussedSummarizationRequest): Observable<CMQueryFocussedSummarization>
    queryFocussedSummarization({ sessionId, cMQueryFocussedSummarizationRequest, aPIVersion }: QueryFocussedSummarizationRequest, opts?: OperationOpts): Observable<AjaxResponse<CMQueryFocussedSummarization>>
    queryFocussedSummarization({ sessionId, cMQueryFocussedSummarizationRequest, aPIVersion }: QueryFocussedSummarizationRequest, opts?: OperationOpts): Observable<CMQueryFocussedSummarization | AjaxResponse<CMQueryFocussedSummarization>> {
        throwIfNullOrUndefined(sessionId, 'sessionId', 'queryFocussedSummarization');
        throwIfNullOrUndefined(cMQueryFocussedSummarizationRequest, 'cMQueryFocussedSummarizationRequest', 'queryFocussedSummarization');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<CMQueryFocussedSummarization>({
            url: '/api/document/qfs',
            method: 'POST',
            headers,
            body: cMQueryFocussedSummarizationRequest,
        }, opts?.responseOpts);
    };

    /**
     * Remove/delete a document by its url.
     * Remove Document
     */
    removeDocument({ organisationId, kbId, url, sourceId, sessionId, aPIVersion }: RemoveDocumentRequest): Observable<JsonMessage>
    removeDocument({ organisationId, kbId, url, sourceId, sessionId, aPIVersion }: RemoveDocumentRequest, opts?: OperationOpts): Observable<AjaxResponse<JsonMessage>>
    removeDocument({ organisationId, kbId, url, sourceId, sessionId, aPIVersion }: RemoveDocumentRequest, opts?: OperationOpts): Observable<JsonMessage | AjaxResponse<JsonMessage>> {
        throwIfNullOrUndefined(organisationId, 'organisationId', 'removeDocument');
        throwIfNullOrUndefined(kbId, 'kbId', 'removeDocument');
        throwIfNullOrUndefined(url, 'url', 'removeDocument');
        throwIfNullOrUndefined(sourceId, 'sourceId', 'removeDocument');
        throwIfNullOrUndefined(sessionId, 'sessionId', 'removeDocument');

        const headers: HttpHeaders = {
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<JsonMessage>({
            url: '/api/document/document/{organisationId}/{kbId}/{url}/{sourceId}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)).replace('{url}', encodeURI(url)).replace('{sourceId}', encodeURI(sourceId)),
            method: 'DELETE',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Remove an inventory breakdown spreadsheet/parquet file from the system
     * Delete Parquet File
     */
    removeParquetFile({ organisationId, kbId, dateTime, sessionId, aPIVersion }: RemoveParquetFileRequest): Observable<Array<JsonMessage>>
    removeParquetFile({ organisationId, kbId, dateTime, sessionId, aPIVersion }: RemoveParquetFileRequest, opts?: OperationOpts): Observable<AjaxResponse<Array<JsonMessage>>>
    removeParquetFile({ organisationId, kbId, dateTime, sessionId, aPIVersion }: RemoveParquetFileRequest, opts?: OperationOpts): Observable<Array<JsonMessage> | AjaxResponse<Array<JsonMessage>>> {
        throwIfNullOrUndefined(organisationId, 'organisationId', 'removeParquetFile');
        throwIfNullOrUndefined(kbId, 'kbId', 'removeParquetFile');
        throwIfNullOrUndefined(dateTime, 'dateTime', 'removeParquetFile');
        throwIfNullOrUndefined(sessionId, 'sessionId', 'removeParquetFile');

        const headers: HttpHeaders = {
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<Array<JsonMessage>>({
            url: '/api/document/parquet/{organisationId}/{kbId}/{dateTime}'.replace('{organisationId}', encodeURI(organisationId)).replace('{kbId}', encodeURI(kbId)).replace('{dateTime}', encodeURI(dateTime)),
            method: 'DELETE',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Summarize a single document using an extractive summarization.
     * Summarize a document
     */
    summarizeDocument({ sessionId, cMSingleDocumentSummaryRequest, aPIVersion }: SummarizeDocumentRequest): Observable<CMSingleDocumentSummary>
    summarizeDocument({ sessionId, cMSingleDocumentSummaryRequest, aPIVersion }: SummarizeDocumentRequest, opts?: OperationOpts): Observable<AjaxResponse<CMSingleDocumentSummary>>
    summarizeDocument({ sessionId, cMSingleDocumentSummaryRequest, aPIVersion }: SummarizeDocumentRequest, opts?: OperationOpts): Observable<CMSingleDocumentSummary | AjaxResponse<CMSingleDocumentSummary>> {
        throwIfNullOrUndefined(sessionId, 'sessionId', 'summarizeDocument');
        throwIfNullOrUndefined(cMSingleDocumentSummaryRequest, 'cMSingleDocumentSummaryRequest', 'summarizeDocument');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(sessionId != null ? { 'session-id': String(sessionId) } : undefined),
            ...(aPIVersion != null ? { 'API-Version': String(aPIVersion) } : undefined),
        };

        return this.request<CMSingleDocumentSummary>({
            url: '/api/document/summarize/document',
            method: 'POST',
            headers,
            body: cMSingleDocumentSummaryRequest,
        }, opts?.responseOpts);
    };

    /**
     * Get the version of SimSage Document Services.
     * Version
     */
    version4(): Observable<CMVersion>
    version4(opts?: OperationOpts): Observable<AjaxResponse<CMVersion>>
    version4(opts?: OperationOpts): Observable<CMVersion | AjaxResponse<CMVersion>> {
        return this.request<CMVersion>({
            url: '/api/document/version',
            method: 'GET',
        }, opts?.responseOpts);
    };

}

/**
 * @export
 * @enum {string}
 */
export enum GetParquetListAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum InventorizeDocumentsAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum InventorizeIndexesAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum QueryFocussedSummarizationAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum RemoveDocumentAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum RemoveParquetFileAPIVersionEnum {
    _1 = '1'
}
/**
 * @export
 * @enum {string}
 */
export enum SummarizeDocumentAPIVersionEnum {
    _1 = '1'
}
