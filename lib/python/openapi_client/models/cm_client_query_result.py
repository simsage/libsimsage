# coding: utf-8

"""
    SimSage REST API

    SimSage REST API

    The version of the OpenAPI document: 7.12.19
    Contact: info@simsage.co.uk
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Dict, List, Union
from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, conlist
from openapi_client.models.cm_saved_search import CMSavedSearch
from openapi_client.models.cm_search_result import CMSearchResult
from openapi_client.models.cm_syn_set import CMSynSet
from openapi_client.models.cm_word_frequency import CMWordFrequency
from openapi_client.models.search_category import SearchCategory

class CMClientQueryResult(BaseModel):
    """
    A SimSage return search-result message for Q&A and semantic-search queries.  # noqa: E501
    """
    message_type: StrictStr = Field(..., alias="messageType")
    assigned_operator_id: StrictStr = Field(..., alias="assignedOperatorId", description="A unique id for this operator's session.")
    operator_name: StrictStr = Field(..., alias="operatorName", description="the name of the operator for clients")
    organisation_id: StrictStr = Field(..., alias="organisationId", description="the organisation (its guid id).")
    kb_id: StrictStr = Field(..., alias="kbId", description="the knowledge-base id (its guid id)")
    text: StrictStr = Field(..., description="the text sent.")
    has_result: StrictBool = Field(..., alias="hasResult", description="is there a result/reply or not?")
    url_list: conlist(StrictStr) = Field(..., alias="urlList", description="a list of reference urls associated with this answer")
    metadata: StrictStr = Field(..., description="metadata associated with the Question/Answer pair, user defined.")
    qna_score: Union[StrictFloat, StrictInt] = Field(..., alias="qnaScore", description="how well the Q&A matcher performed a value between 0.0 and 1.0")
    image_list: conlist(StrictStr) = Field(..., alias="imageList", description="A list of image urls associated with the Q&A pair")
    total_document_count: StrictInt = Field(..., alias="totalDocumentCount", description="the total number of documents found (but not included necessarily)")
    shard_size_list: conlist(StrictInt) = Field(..., alias="shardSizeList", description="Index sharding values.  These are used by the internal engine to determine the status of results across different shards in SimSage.  Leave this value alone.  It is set by SimSage.  Pass it back to SimSage as you got it if you're paginating the same query.")
    result_list: conlist(CMSearchResult) = Field(..., alias="resultList", description="the actual search results, one for each item found")
    spelling_correction: StrictStr = Field(..., alias="spellingCorrection", description="a spelling correction suggestion if appropriate and enabled.")
    semantic_set: Dict[str, conlist(CMWordFrequency)] = Field(..., alias="semanticSet", description="A descriptor of semantic categories and words with frequencies in each category")
    know_email: StrictBool = Field(..., alias="knowEmail", description="do we know the email address of this person?  if they've supplied it in the past this will be set to true.")
    category_list: conlist(SearchCategory) = Field(..., alias="categoryList", description="updated categories (if applicable) with updated counts")
    syn_set_list: conlist(CMSynSet) = Field(..., alias="synSetList", description="A list of syn-sets used in the query")
    custom_render: StrictBool = Field(..., alias="customRender", description="Does this source require custom render templates or use ordinary search-results?")
    saved_search_list: conlist(CMSavedSearch) = Field(..., alias="savedSearchList", description="a list of previous searches if applicable")
    query_summarization: StrictStr = Field(..., alias="querySummarization", description="an optional summarization of the search results")
    __properties = ["messageType", "assignedOperatorId", "operatorName", "organisationId", "kbId", "text", "hasResult", "urlList", "metadata", "qnaScore", "imageList", "totalDocumentCount", "shardSizeList", "resultList", "spellingCorrection", "semanticSet", "knowEmail", "categoryList", "synSetList", "customRender", "savedSearchList", "querySummarization"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> CMClientQueryResult:
        """Create an instance of CMClientQueryResult from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each item in result_list (list)
        _items = []
        if self.result_list:
            for _item in self.result_list:
                if _item:
                    _items.append(_item.to_dict())
            _dict['resultList'] = _items
        # override the default output from pydantic by calling `to_dict()` of each value in semantic_set (dict of array)
        _field_dict_of_array = {}
        if self.semantic_set:
            for _key in self.semantic_set:
                if self.semantic_set[_key]:
                    _field_dict_of_array[_key] = [
                        _item.to_dict() for _item in self.semantic_set[_key]
                    ]
            _dict['semanticSet'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each item in category_list (list)
        _items = []
        if self.category_list:
            for _item in self.category_list:
                if _item:
                    _items.append(_item.to_dict())
            _dict['categoryList'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in syn_set_list (list)
        _items = []
        if self.syn_set_list:
            for _item in self.syn_set_list:
                if _item:
                    _items.append(_item.to_dict())
            _dict['synSetList'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in saved_search_list (list)
        _items = []
        if self.saved_search_list:
            for _item in self.saved_search_list:
                if _item:
                    _items.append(_item.to_dict())
            _dict['savedSearchList'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> CMClientQueryResult:
        """Create an instance of CMClientQueryResult from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return CMClientQueryResult.parse_obj(obj)

        _obj = CMClientQueryResult.parse_obj({
            "message_type": obj.get("messageType"),
            "assigned_operator_id": obj.get("assignedOperatorId"),
            "operator_name": obj.get("operatorName"),
            "organisation_id": obj.get("organisationId"),
            "kb_id": obj.get("kbId"),
            "text": obj.get("text"),
            "has_result": obj.get("hasResult"),
            "url_list": obj.get("urlList"),
            "metadata": obj.get("metadata"),
            "qna_score": obj.get("qnaScore"),
            "image_list": obj.get("imageList"),
            "total_document_count": obj.get("totalDocumentCount"),
            "shard_size_list": obj.get("shardSizeList"),
            "result_list": [CMSearchResult.from_dict(_item) for _item in obj.get("resultList")] if obj.get("resultList") is not None else None,
            "spelling_correction": obj.get("spellingCorrection"),
            "semantic_set": dict(
                (_k,
                        [CMWordFrequency.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("semanticSet").items()
            ),
            "know_email": obj.get("knowEmail"),
            "category_list": [SearchCategory.from_dict(_item) for _item in obj.get("categoryList")] if obj.get("categoryList") is not None else None,
            "syn_set_list": [CMSynSet.from_dict(_item) for _item in obj.get("synSetList")] if obj.get("synSetList") is not None else None,
            "custom_render": obj.get("customRender"),
            "saved_search_list": [CMSavedSearch.from_dict(_item) for _item in obj.get("savedSearchList")] if obj.get("savedSearchList") is not None else None,
            "query_summarization": obj.get("querySummarization")
        })
        return _obj


